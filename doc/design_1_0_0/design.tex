
%\documentclass[10pt,twoside,twocolumn]{article}
\documentclass[12pt,twoside]{article}
\usepackage[bf,small]{caption}
\usepackage[letterpaper,hmargin=1in,vmargin=1in]{geometry}
\usepackage{paralist} % comapctitem, compactdesc, compactenum
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage{times}
\usepackage{hyperref}
\usepackage{algorithmic}
\usepackage{graphicx}
\graphicspath{{./graphics/}}
\usepackage{xspace}
\usepackage{verbatim}
\hyphenation{Sub-Bytes Shift-Rows Mix-Col-umns Add-Round-Key}

\setlength{\parskip}{12pt}
\setlength{\parindent}{0pt}

\newcommand{\hdb}{\emph{hashdb}\xspace}
\newcommand{\bulk}{\emph{bulk\_extractor}\xspace}
\newcommand{\mdd}{\emph{md5deep}\xspace}
\newcommand{\mi}{\textbf{map iterator}\xspace}
\newcommand{\mmi}{\textbf{multimap iterator}\xspace}

\begin{document}

\title{\hdb Design Document}
\author{Bruce Allen}
\maketitle

\begin{abstract}
This document defines the design of the \hdb tool and library
for \hdb v1.0.0, which is different from that of \hdb v0.9.1.
The \hdb Checker and Manager are merged.
the \hdb Library interfaces are changed and support more capability.
\end{abstract}

\section{Changes for v1.0.0}
\paragraph{Database Types}
Two parameters define the database type when creating a new database:
\begin{compactitem}
\item \textbf{Data Size} specifies the block size,
or select 0 to store hashes of any size, useful for managing file hashes.
\item \textbf{Hash Type} specifies the hash type, such as MD5 or SHA1.
We do not mix hash types in a database because hash types have differing sizes.
If mixing hash sizes is really desired, we can truncate or zero-fill
hash values in the database.
\end{compactitem}
\paragraph{Remote Modify}
We can add or remove hash elements remotely over a socket.
\paragraph{Renamed Commands}
Some \hdb tool commands are renamed to specifically indicate their function.

\section{\hdb Services}
\hdb services are provided by the \hdb tool and the \hdb library.
\subsection{\hdb Tool Commands}
\begin{compactitem}
\item Create a \hdb database
\item Import hashes from DFXML
\item Export hashes to DFXML
\item Add hashes in DFXML into database
\item Copy a database to a second database
\item Merge two databases into a third database
\item Remove hashes in DFXML from database
\item Rebuild Bloom filters for database
\item Get hash source information
\item Get database information
\item Run as a Server service
\end{compactitem}

Specifically:
\begin{compactitem}
\item \texttt{create <hashdb settings> <bloom filter settings> <hashdb>} \\
Create a new empty \hdb given the specified settings.
\item \texttt{import [-r <repository name>] <DFXML file> <hashdb>} \\
Import hashes from the DFXML file into the existing \hdb
using the given repository name.
\item \texttt{export <hashdb> <DFXML file>} \\
Export hashes from the hashdb to the new DFXML file.
\item \texttt{copy <hashdb 1> <hashdb 2>} \\
Copy hashes in database 1 into database 2
using a \mmi over database 1.
\item \texttt{merge <hashdb 1> <hashdb 2> <hashdb 3>} \\
Merge databases 1 and 2 into 3
using {\mmi}s over databases 1 and 2 in sorted order.
\item \texttt{remove <hashdb 1> <hashdb 2>} \\
Remove hashes in database 1 from database 2
using a \mmi over database 1.
\item \texttt{remove\_dfxml <DFXML file> <hashdb>} \\
Remove hashes in the DFXML file from the database.
\item \texttt{deduplicate <hashdb1> <hashdb2>} \\
Copy hashes in hashdb1 to hashdb2,
except for hashes that appear more than once.
\item \texttt{rebuild\_bloom <bloom filter settings> <hashdb>} \\
Rebuild the Bloom filters with new settings
using a \mi over the given database.
\item \texttt{server <hashdb> <socket>} \\
Start the \hdb tool as a server service using the database
at the specified socket.
This service uses all \hdb Library interfaces.
\item \texttt{query\_hash <path or socket> <DFXML file>} \\
Print out hashes in the \hdb that match hashes in the DFXML file.
\item \texttt{get\_hash\_source <path or socket> <identified\_blocks.txt> <output text file>} \\
Create output file from input, showing full source intormation.
\item \texttt{get\_hashdb\_info <path or socket>} \\
Print out information about the given database.
\end{compactitem}

\subsubsection{Changes from \hdb v0.9.1}
\begin{compactitem}
\item The parameters for the tuning parameters and bloom filters
remain the same.
\item The \texttt{create} command is new.
The user must create a database before using \texttt{add} or \texttt{merge}.
Alternatively, \texttt{merge} could require parameters for creating
a new database.
\item The \hdb tool uses the \hdb library
for services the \hdb library provides.
\end{compactitem}

\subsection{\hdb Library Interfaces}
\begin{compactitem}
\item Open
\item Insert hashes
\item Remove hashes
\item Find hashes
\item Look up hash sources
\item Get \hdb information
\end{compactitem}

These interfaces permit future expansion to other hash types
by having the hash type in their name.
To start, the \emph{MD5} hash type is supported.

% open
\subsubsection{Open \hdb}
Open a \hdb service that uses the database at the given file path or socket.
If the string contains adjacent // markers, a socket is indicated,
otherwise a file path is indicated.
Here is the constructor:
\begin{small}
\begin{verbatim}
hashdb_md5_h(const std::string &hashdb_service);
\end{verbatim}
\end{small}

% insert hashes
\subsubsection{Insert Hashes}
Insert the hashes and their associated source information
into the opened database and log the change to file \texttt{log}.
\begin{small}
\begin{verbatim}
insert_md5_hashes(const insert_md5_hashes_t &insert_hashes);

struct insert_md5_hash_t {
    uint8_t digest[16];
    std::string repository_name;
    std::string filename;
    uint64_t file_offset;
};

typedef std::vector<insert_md5_hash_t> insert_md5_hashes_t;
\end{verbatim}
\end{small}

% remove hashes
\subsubsection{Remove Hashes}
Removes hashes that exactly match the specified source information
and log the change to file \texttt{log}.
The data structure required for erasing hashes
is the same as that for inserting hashes.

\begin{small}
\begin{verbatim}
remove_md5_hashes(const remove_md5_hashes_t& remove_hashes);

typedef insert_md5_hash_t remove_md5_hash_t;

typedef insert_md5_hashes_t remove_md5_hashes_t;
\end{verbatim}
\end{small}

% find hashes
\subsubsection{Find Hashes}
Finds matching hashes and returns the hashes that match,
along with the \emph{source lookup encoding}
associated with matching hashes.
A hash index is used so that the callee can map responses back
to their original request entries.

\begin{small}
\begin{verbatim}
find_md5_hashes(const find_md5_hashes_t &find_hashes,
            found_md5_hashes_t &found_hashes);

struct find_md5_hash_t {
    uint32_t id;
    uint8_t digest[16];
};

typedef std::vector<find_md5_hash_t> find_md5_hashes_t;

struct found_md5_hash_t {
    uint32_t id;
    uint8_t digest[16];
    uint32_t count;
};

typedef std::vector<found_md5_hash_t> found_md5_hashes_t;
\end{verbatim}
\end{small}

% look up hash sources
\subsubsection{Look Up Hash Sources}
Look up source information for hash values provided.
There may be multiple sources for a hash value.
Source information consists of the repository name, filename, and file offset
of where the hash was sourced from.

\begin{small}
\begin{verbatim}
look_up_md5_hash_sources(const look_up_md5_hash_sources_t& look_up_hash_sources,
                         looked_up_md5_hash_sources_t& looked_up_hash_sources);

struct look_up_md5_hash_source_t {
    uint8_t digest[16];
};

typedef std::vector<look_up_md5_hash_source_t> look_up_md5_hash_sources_t;

struct looked_up_md5_hash_source_t {
    std::string repository_name;
    std::string filename;
    uint64_t file_offset;
};

typedef std::vector<pair<uint8_t[16], std::vector<looked_up_md5_hash_source_t>
                looked_up_md5_hash_sources_t;
\end{verbatim}
\end{small}

% get hashdb info
\subsubsection{Get \hdb Information}
Returns information about the opened database.

\begin{small}
\begin{verbatim}
get_hashdb_info(std::string& information);
\end{verbatim}
\end{small}

\subsection{\hdb Server}
The \hdb server services requests issued to the \hdb library.
\hdb server actions are straightforward.

When a \hdb library service or the \hdb tools need to use a \hdb server,
and the service is at a local path rather than at a socket,
it should perform the following steps:
\begin{algorithmic}
\STATE create the server service as a thread using the machine-local socket
\STATE use the server service using the system-local socket
\STATE destroy the locally running server service thread
\end{algorithmic}

Here is the basic flow for the \hdb server:
\begin{algorithmic}
\STATE Instantiate a \hdb element manager
\WHILE{true}
  \IF{add hashes}
    \STATE create the change logger
    \WHILE{hashes to add}
      \STATE add hash using the \hdb element manager
    \ENDWHILE
  \ELSIF{remove hashes}
    \STATE create the change logger
    \WHILE{hashes to remove}
      \STATE remove hash using the \hdb element manager
    \ENDWHILE
  \ELSIF{find hashes}
    \WHILE{hashes to look up}
      \IF{match}
        \STATE add hash and count to response
      \ENDIF
    \ENDWHILE
  \ELSIF{get info}
    \STATE put info into response
  \ENDIF
\ENDWHILE
\end{algorithmic}

\section{File Modules - Mid-Level Database File Drivers}
File modules manage access to database files.
They are typically initialized with \texttt{hashdb\_dir} and file access mode
\texttt{RW\_NEW}, \texttt{RW\_MODIFY}, or \texttt{READ\_ONLY}.
They require hash key type \texttt{<T>}.

\begin{compactitem}
\item Map Manager
\item Map Iterator
\item Multmiap Manager
\item Multimap Iterator
\item Source Lookup Index Manager
\item Bloom Filter Manager
\item Settings Manager
\item Logger
\end{compactitem}

% map manager
\subsection{Map Manager}
This module manages mapped hash storage.
It has been renamed from \textit{Hash Store}.
\begin{compactitem}
\item The key \texttt{T} is the \texttt{uint8\_t[SIZE]} hash digest such as MD5,
and the payload value is the \texttt{uint64\_t} source lookup encoding.
\item The source lookup encoding consists of $32-40$ bits
of source lookup index and $32-24$ bits of block offset value,
but this detail does not matter to the Map Manager.
\item The hash map maps to the \texttt{hash\_map\_store} file.
\item Provides Interfaces to insert, erase, look up, and change elements.
\item An iterator is available for walking the hash map.
\end{compactitem}

Here are the interfaces:
\begin{small}
\begin{verbatim}
map_manager_t<class T>(const std::string& hashdb_dir,
                       file_mode_type_t file_mode,
                       map_type_t map_type);
pair<map_iterator_t<T>, bool> emplace(const T& key,
                                      uint64_t source_lookup_encoding);
bool erase(const T& key);
pair<map_iterator_t<T>, bool> change(const T& key,
                                      uint64_t source_lookup_encoding);
map_iterator_t<T> find(const T& key);
bool has(const T& key);   // faster than find()
map_iterator_t<T> begin() const;
map_iterator_t<T> end() const;
size_t size();
\end{verbatim}
\end{small}

% map iterator
\subsection{Map Iterator}
\texttt{map\_iterator\_t} dereferences to
key, source lookup index pair\texttt{<T, uint64\_t>}.

% multimap manager
\subsection{Multimap Manager}
This module manages multimap hash storage.
It has been renamed from \textit{Hash duplicates Store}.
\begin{compactitem}
\item The key \texttt{T} is the \texttt{uint8\_t[SIZE]} hash digest such as MD5,
and the payload value is the \texttt{uint64\_t} source lookup encoding.
\item The source lookup encoding consists of $32-40$ bits
of source lookup index and $32-24$ bits of block offset value,
but this detail does not matter at this low storage level.
\item The hash multimap maps to the \texttt{hash\_multimap\_store} file.
\item Provides Interfaces to insert, erase, and look up elements.
\item An iterator is available for walking
between elements \texttt{[a,b)} of a key in the hash multimap.
\item Begin and end accessors are not provided.
\end{compactitem}

Here are the interfaces:
\begin{small}
\begin{verbatim}
multimap_manager_t<class T>(string& hashdb_dir,
                            file_mode_type_t file_mode,
                            multimap_type_t multimap_type);
bool emplace(const T& key,
             uint32_t max_duplicates,
             uint64_t source_lookup_encoding);
bool erase(const T& key, uint64_t source_lookup_encoding);
size_t erase_range(const& key T);
pair<multimap_iterator_t<T>, multimap_iterator_t<T>> equal_range(key T);
bool has(const T& key, uint64_t source_lookup_encoding);
bool has_range(const T& key);
size_t size() const;
\end{verbatim}
\end{small}

% multimap iterator
\subsection{Multimap Iterator}
\texttt{multimap\_iterator\_t} dereferences to
key, source lookup index pair\texttt{<T, uint64\_t>}.

% source lookup index manager
\subsection{Source Lookup Index Manager}
This module manages the association between an index
and its associated repository\_name, filename pair.
\begin{compactitem}
\item It wraps source lookup capability under one purposed interface.
\item It manages the lookup store, filename store,
and repository name store files required by the three B-Tree multisets
and uses
\texttt{source\_lookup\_store},
\texttt{source\_filename\_store}, and
\texttt{source\_repository\_name\_store}
filenames, each one with
\texttt{.dat}, \texttt{.idx1}, and \texttt{.idx2} extensions.
\item Provides Interfaces to insert indexes
and to find indexes or repository name, filename pairs.
\end{compactitem}

Here are the interfaces:

\begin{small}
\begin{verbatim}
source_lookup_index_manager_t(hashdb_dir, file_mode);

pair<bool, uint64_t> insert(const std::string& repository_name,
                            const std::string& filename);

pair<bool, uint64_t> find(const std::string& repository_name,
                          const std::string& filename);

pair<string rep_name, string filename> find(uint64_t source_lookup_index);
\end{verbatim}
\end{small}

\subsection{Bloom Filter Manager}
\begin{compactitem}
\item Two Bloom filters are managed, Bloom1 and Bloom2.
\item Initialization parameters set the enabled state and runtime state of both.
\item The \hdb manager uses this to set or check for hashes.
\item Bloom filters help performance by indicating when a hash is not present.
\end{compactitem}

Here are the interfaces:

\begin{small}
\begin{verbatim}
bloom_filter_t<T>(const std::string& filename,
               file_mode_type_t file_mode,
               const lots of settings);

void add_hash_value(const T& key);

is_positive(const T& key);
\end{verbatim}
\end{small}

\subsection{Settings Manager}
Many of the storage types in the \hdb database use configurable \hdb settings.
Refer to \texttt{hashdb\_settings\_t}.

Here are the interfaces:

\begin{small}
\begin{verbatim}
static hashdb_settings_t read_settings(const std::string& hashdb_dir);

static void write_settings(const std::string& hashdb_dir,
                           const hashdb_settings_t& settings);
\end{verbatim}
\end{small}

\subsection{Logger}
The logger manages logging to the \hdb \texttt{log.xml} file.
The log is created when the logger object opens,
and is closed by close or when the logger is destroyed,
for example by losing scope.
 
Here are the interfaces:

\begin{small}
\begin{verbatim}
logger_t(hashdb_dir);
void add_timestamp(name);
void add_hashdb_settings(const hashdb_settings_t& settings);
void add_hashdb_changes(const hashdb_changes_t& changes);
template<typename T> void add(const std::string& tag, const T& value);
\end{verbatim}
\end{small}

\section{Map-Multimap Abstraction Layer}
\begin{compactitem}
\item The Map-Multimap abstraction layer
provides a unified \hdb treatment of the map and multimap
while still using lower-level \texttt{T key}
and \texttt{uint64\_t source\_lookup\_encoding} types
rather than the higher-level \texttt{hashdb\_element\_t} class.
\item The Map-Multimap abstraction layer fits above the file modules
and below the \hdb modules.
\item It consists of \texttt{map\_multimap\_manager\_t<T>}
and \texttt{map\_multimap\_iterator\_t<T>}.
\end{compactitem}

\subsection{Map-Multimap Manager}
The \texttt{map\_multimap\_manager\_t}
provides services required for accessing the hash database
as a whole.  It hides the map manager, multimap manager, and bloom filter.
Changes to the \hdb are noted in \texttt{hashdb\_changes\_t}.

Actions:
\begin{compactitem}
\item Open a hash database as
\texttt{RW\_NEW}, \texttt{RW\_MODIFY}, or \texttt{READ\_ONLY}.
\item Emplace a \texttt{T, source\_lookup\_encoding} entry noting the change.
\item Remove a \texttt{T, source\_lookup\_encoding} entry noting the change.
\item Remove a \texttt{T} entry noting the change.
\item See if T key exists, checking Bloom first.
\item Provide a \texttt{map\_multimap\_iterator} via begin() and end()
for iterating over all hash values.
Iterator dereferences to \texttt{pair<T, uint64\_t}.
\item Provide zero-overhead size functions for map and multimap,
more for completeness than for usefulness.
\end{compactitem}

Interfaces:

\begin{small}
\begin{verbatim}
map_multimap_manager_t<T>(const std::string& hashdb_dir,
                          file_mode_t file_mode_type);

void emplace(const T& key, uint64_t source_lookup_encoding,
             hashdb_changes_t &hashdb_changes);

void remove(const T& key, uint64_t source_lookup_encoding,
            hashdb_changes_t& hashdb_changes);

void remove_key(const T& key, hashdb_changes_t& hashdb_changes);

bool has_key(const T& key);

pair<T, uint64_t> begin() const;

pair<T, uint64_t> end() const;

size_t map_size();

size_t multimap_size();
\end{verbatim}
\end{small}

% map_multimap iterator
\subsection{Map-Multimap Iterator}
\texttt{map\_multimap\_iterator\_t<T>} dereferences to \\
\texttt{pair(T key, uint64\_t source\_lookup\_encoding\_t)}.

\section{\hdb Modules}
\subsection{\hdb Manager}
The \texttt{hashdb\_manager\_t}
provides services required for accessing the hash database
as a whole.  It hides the map manager, multimap manager, and bloom filter.
Changes to the \hdb are noted in the \hdb change logger.

Actions:
\begin{compactitem}
\item Open a hash database as
\texttt{RW\_NEW}, \texttt{RW\_MODIFY}, or \texttt{READ\_ONLY}.
\item Insert a \texttt{hashdb\_element\_t} entry noting the change.
\item Remove a \texttt{hashdb\_element\_t} entry noting the change.
\item Remove all elements of a key
specified by \texttt{hashdigest\_t}, noting the change.
\item See if a hash identified by key in
type \texttt{hashdigest\_t} exists, checking Bloom first.
\item Provide a \hdb iterator via begin() and end()
for iterating over all hash values.
\end{compactitem}

Interfaces:

% hashdb manager
\begin{small}
\begin{verbatim}
hashdb_manager_t(const std::string& hashdb_dir,
                 file_mode_t file_mode);

void insert(const hashdb_element_t&, hashdb_changes_t&);

void remove(const hashdb_element_t&, hashdb_changes_t&);

void remove_key(const hashdigest_t&, hashdb_changes_t&);

bool has_key(const hashdigest_t&);

size_t map_size();

size_t multimap_size();

hashdb_iterator_t begin() const;

hashdb_iterator_t end() const;
\end{verbatim}
\end{small}

% hashdb iterator
\subsection{\hdb Iterator}
\hdb iterator dereferences to \texttt{hashdb\_element\_t}.

% hashdigest type
\subsection{Hashdigest Type}
\texttt{hashdigest\_t} contains a hash value and its type
as strings, unbound from its native hash type.
\begin{small}
\begin{verbatim}
struct hashdigest_t {
  std::string hashdigest;
  std::string hashdigest_type;    // MD5, SHA1, etc.

  hashdigest_t(string hashdigest, string hashdigest_type);
  hashdigest_t(md5_t);
  hashdigest_t(sha1_t);
  hashdigest_t(sha256_t);
};
\end{verbatim}
\end{small}

% hashdb element
\subsection{Hashdb Element}
A \texttt{hashdb\_element\_t} fully qualifies a hash source.
\begin{compactitem}
\item It has all the fields required to fully define a hash source.
\item The \texttt{hashdigest} is a string, so we don't to use \texttt{<T>}.
\end{compactitem}

Specifically:
\begin{small}
\begin{verbatim}
struct hashdb_element_t {
    std::string hashdigest;
    std::string hashdigest_type;    // MD5, SHA1, etc.
    uint32_t block_size;            // e.g. 4096
    std::string repository_name;
    std::string filename;
    uint64_t file_offset;
};
\end{verbatim}
\end{small}

\subsection{\hdb Changes}
This structure is used for tracking changes to the \hdb.
The \hdb manager increments these variables
as requests are made to insert or remove \hdb elements.
Use the \texttt{logger} to log \hdb changes.

Note that logs are now written at the \hdb library level
for each invocation of the library,
rather than at the tool level, which logged once
for the invocation of the \hdb tool.
This is different from v0.9.1.

\begin{small}
\begin{verbatim}
class hashdb_changes_t {
      // insert
      uint32_t hashes_inserted;
      uint32_t hashes_not_inserted_wrong_hash_block_size;
      uint32_t hashes_not_inserted_file_offset_not_aligned;
      uint32_t hashes_not_inserted_wrong_hashdigest_type;
      uint32_t hashes_not_inserted_exceeds_max_duplicates;
      uint32_t hashes_not_inserted_duplicate_element;

      // remove
      uint32_t hashes_removed;
      uint32_t hashes_not_removed_wrong_hash_block_size;
      uint32_t hashes_not_removed_file_offset_not_aligned;
      uint32_t hashes_not_removed_wrong_hashdigest_type;
      uint32_t hashes_not_removed_no_hash;
      uint32_t hashes_not_removed_no_element;
};
\end{verbatim}
\end{small}

% source lookup encoding
\subsection{Source Lookup Encoding}
The source lookup encoding provides algorithms for working with a
\texttt{uint64\_t}
as a source lookup encoding containing a source lookup index,
a hash block offset, and a count value.
These algorithms are
implemented in namespace \texttt{source\_lookup\_encoding}.
This encoding is an optimization for saving space in memory.
Here are some properties of this encoding:
\begin{compactitem}
\item If the embedded count value $=$ 1,
the source lookup index and hash block offset
have valid source lookup values.
The \texttt{uint64\_t} value is distributed between the
source lookup index and hash block offset as follows:
  \begin{compactitem}
  \item number of index bits goes into the source lookup index.
  \item 32 $-$ number of index bits goes into the hash block offset.
  \end{compactitem}
\item If the embedded count value $>$ 1,
the source lookup index and hash block offset accessors
are not used and return 0.
\item If the hash is a file hash, the block offset will be 0, as expected.
\item If an attempt is made to compose a source lookup encoding
from a source lookup index or a hash block offset
that is too large, an error will be emitted to \texttt{stderr}
and 0 will be returned.
\item A count value is indicated when the most significant 32 bits
of the \texttt{uint64\_t} $=$ \texttt{0xffff}.
\end{compactitem}

Here are the interfaces:
\begin{small}
\begin{verbatim}
static uint64_t get_source_lookup_encoding(
                 uint8_t source_lookup_index_bits,
                 uint64_t source_lookup_index,
                 uint64_t hash_block_offset);

static uint64_t get_source_lookup_encoding(uint32_t count);

static uint32_t get_count(uint64_t source_lookup_encoding);

static uint64_t get_source_lookup_index(
                 uint8_t source_lookup_index_bits,
                 uint64_t source_lookup_encoding);

static uint64_t get_hash_block_offset(
                 uint8_t source_lookup_index_bits,
                 uint64_t source_lookup_encoding);
\end{verbatim}
\end{small}



\end{document}

