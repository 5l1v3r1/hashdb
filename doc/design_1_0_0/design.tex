
%\documentclass[10pt,twoside,twocolumn]{article}
\documentclass[12pt,twoside]{article}
\usepackage[bf,small]{caption}
\usepackage[letterpaper,hmargin=1in,vmargin=1in]{geometry}
\usepackage{paralist} % comapctitem, compactdesc, compactenum
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage{times}
\usepackage{hyperref}
\usepackage{algorithmic}
\usepackage{graphicx}
\graphicspath{{./graphics/}}
\usepackage{xspace}
\usepackage{verbatim}
\hyphenation{Sub-Bytes Shift-Rows Mix-Col-umns Add-Round-Key}

\setlength{\parskip}{12pt}
\setlength{\parindent}{0pt}

\newcommand{\hdb}{\emph{hashdb}\xspace}
\newcommand{\bulk}{\emph{bulk\_extractor}\xspace}
\newcommand{\mdd}{\emph{md5deep}\xspace}

\begin{document}

\title{\hdb Design Document}
\author{Bruce Allen}
\maketitle

\begin{abstract}
This document defines the design of the \hdb tool and library
for \hdb v1.0.0, which is different from that of \hdb v0.9.1.
The \hdb Checker and Manager are moved,
the \hdb Library supports add capability,
interfaces are renamed.
\end{abstract}

\section{\hdb Services}
\hdb services are provided by the \hdb tool and the \hdb library.
\subsection{\hdb Tool Commands}
\begin{compactitem}
\item Create a \hdb database
\item Import hashes from DFXML
\item Export hashes to DFXML
\item Add hashes
\item Merge two databases into a third one
\item Erase hashes
\item Rebuild Bloom Filters
\item Run as a Server service
\item Get database information
\end{compactitem}

\begin{compactitem}
\item \texttt{create <tuning parameters> <hashdb>} \\
Create a new empty \hdb given the tuning parameters.
\item \texttt{import <repository name> <DFXML file> <hashdb>} \\
Import hashes from the DFXML file into the existing \hdb
using the given repository name.

Uses the \hdb Library \texttt{insert\_hashes} interface.
\item \texttt{export <hashdb> <DFXML file>} \\
Export hashes from the hashdb to the new DFXML file.
\item \texttt{add <hashdb 1> <hashdb 2>} \\
Add database 1 into database 2
using a \emph{hashdb multimap iterator} on database 1.
Uses the \hdb Library \texttt{insert\_hashes} interface.
\item \texttt{merge <hashdb 1> <hashdb 2> <hashdb 3>} \\
Merge databases 1 and 2 into existing database 3
using \emph{hashdb multimap iterator}s on databases 1 and 2 in sorted order.
Uses the \hdb Library \texttt{insert\_hashes} interface.
\item \texttt{erase <hashdb 1> <hashdb 2>} \\
Erase hashes in database 1 from database 2
using a \emph{hashdb multimap iterator} on database 1.
Uses the \hdb Library \texttt{erase\_hashes} interface.
\item \texttt{rebuild bloom <bloom filter parameters> <hashdb>} \\
Rebuild the Bloom filters
using a \emph{hashdb map iterator} on the given database.
\item \texttt{get\_hashdb\_info <hashdb>} \\
Retrieve information about the given database.
\item \texttt{server <hashdb>} \\
Start the \hdb tool as a server service using the specified database.
This service uses all \hdb Library interfaces.
\end{compactitem}

\subsubsection{Changes from \hdb v0.9.1}
\begin{compactitem}
\item The parameters for the tuning parameters and bloom filters
remain the same.
\item The \texttt{create} command is new.
The user must create a database before using \texttt{add} or \texttt{merge}.
Alternatively, \texttt{merge} could require parameters for creating
a new database.
\end{compactitem}

\subsection{\hdb Library Interfaces}
\begin{compactitem}
\item Open
\item Insert hashes
\item Erase hashes
\item Find hashes
\item Look up hash sources
\item Get \hdb information
\end{compactitem}

These interfaces permit future expansion to other hash types
by having the hash type in their name.
To start, the \emph{MD5} hash type is supported.

% open
\subsubsection{Open \hdb}
Open a \hdb service that uses the database at the given file path or socket.
If the string contains adjacent // markers, a socket is indicated,
otherwise a file path is indicated.
Here is the constructor:
\begin{small}
\begin{verbatim}
hashdb_md5_h(const std::string &hashdb_service);
\end{verbatim}
\end{small}

% insert hashes
\subsubsection{Insert Hashes}
Insert the hashes and their associated source information
into the opened database.
\begin{small}
\begin{verbatim}
insert_md5_hashes(const insert_md5_hashes_t &insert_hashes);

struct insert_md5_hash_t {
    uint8_t digest[16];
    std::string repository_name;
    std::string filename;
    uint64_t file_offset;
};

typedef std::vector<insert_md5_hash_t> insert_md5_hashes_t;
\end{verbatim}
\end{small}

% erase hashes
\subsubsection{Erase Hashes}
Removes hashes that exactly match the specified source information.
The data structure required for erasing hashes
is the same as that for inserting hashes.

\begin{small}
\begin{verbatim}
erase_md5_hashes(const erase_md5_hashes_t& erase_hashes);

typedef insert_md5_hash_t erase_md5_hash_t;

typedef insert_md5_hashes_t erase_md5_hashes_t;
\end{verbatim}
\end{small}

% find hashes
\subsubsection{Find Hashes}
Finds matching hashes and returns the hashes that match,
along with the \emph{source lookup record} value
associated with matching hashes.
A hash index is used so that the callee can map responses back
to their original request entries.

\begin{small}
\begin{verbatim}
find_md5_hashes(const find_md5_hashes_t &find_hashes,
            found_md5_hashes_t &found_hashes);

struct find_md5_hash_t {
    uint32_t id;
    uint8_t digest[16];
};

typedef std::vector<find_md5_hash_t> find_md5_hashes_t;

struct found_md5_hash_t {
    uint32_t id;
    uint8_t digest[16];
    uint64_t source_lookup_record;
};

typedef std::vector<found_md5_hash_t> found_md5_hashes_t;
\end{verbatim}
\end{small}

% look up hash sources
\subsubsection{Look Up Hash Sources}
Look up source information for hash values provided.
There may be multiple sources for a hash value.
Source information consists of the repository name, filename, and file offset
of where the hash was sourced from.

\begin{small}
\begin{verbatim}
look_up_md5_hash_sources(const look_up_md5_hash_sources_t& look_up_hash_sources,
                         looked_up_md5_hash_sources_t& looked_up_hash_sources);

struct look_up_md5_hash_source_t {
    uint8_t digest[16];
};

typedef std::vector<look_up_md5_hash_source_t> look_up_md5_hash_sources_t;

struct looked_up_md5_hash_source_t {
    std::string repository_name;
    std::string filename;
    uint64_t file_offset;
};

typedef std::vector<pair<uint8_t[16], std::vector<looked_up_md5_hash_source_t>
                looked_up_md5_hash_sources_t;
\end{verbatim}
\end{small}

% get hashdb info
\subsubsection{Get \hdb Information}
Returns information about the opened database.

\begin{small}
\begin{verbatim}
get_hashdb_info(std::string& information);
\end{verbatim}
\end{small}

\section{Low-Level \hdb Modules}

% hash store
\subsection{Hash Store}
This module manages mapped hash storage.
\begin{compactitem}
\item This provides a map of hashes (this is not a multimap).
\item Elements consist of a
\texttt{uint8\_t[16]} block hash key and a
\texttt{source\_lookup\_record} value.
\item The \texttt{source\_lookup\_record} consists of $32-40$ bits
of source lookup index and $32-24$ bits of block offset value.
\item Hash storage maps to the \texttt{hash\_store} file.
\item Provides Interfaces to insert, erase, look up, and change elements.
\item Iterator \texttt{hash\_store\_iterator\_t} is available
for walking the hash store.
\end{compactitem}

% hash duplicates store
\subsection{Hash Duplicates Store}
This module manages storage for hash duplicates.
\begin{compactitem}
\item This provides a multi-map of hashes.
\item Hash duplicates storage maps to the \texttt{hash\_duplicates\_store} file.
\item Elements consist of a
\texttt{uint8\_t[16]} block hash key and a
\texttt{source\_lookup\_record} value.
\item Provides interfaces to insert, erase, and look up elements.
\item No iterator is provided with this interface.
\end{compactitem}

% source lookup manager
\subsection{Source Lookup Manager}
This module manages source lookups.
\begin{compactitem}
\item It wraps three multiset files under one purposed interface.
\item It manages the lookup store, filename store,
and repository name store files: \\
\texttt{
source\_lookup\_store.dat \\
source\_lookup\_store.idx1 \\
source\_lookup\_store.idx2 \\
source\_filename\_store.dat \\
source\_filename\_store.idx1 \\
source\_filename\_store.idx2 \\
source\_repository\_name\_store.dat \\
source\_repository\_name\_store.idx1 \\
source\_repository\_name\_store.idx2 \\
}
\item Provides Interfaces to get source information
from \texttt{source\_lookup\_index},
to get the \texttt{source\_lookup\_index} from source information,
and to insert elements by specifying the repository name, filename,
and \texttt{source\_lookup\_index}.
\end{compactitem}

\section{Mid-Level \hdb Database Module}
This mid-level \texttt{hashdb\_db\_t} module
provides all services for working with a \hdb database
on the \hdb element level.
A \hdb element consists of the following pair:
\begin{compactitem}
\item A block hash value.
\item A hash source record containing:
  \begin{compactitem}
  \item file offset
  \item repository name
  \item filename
  \end{compactitem}
\end{compactitem}

Interfaces support the following:
\begin{compactitem}
\item Insert a \hdb element.
\item Remove a \hdb element.
\item See if a hash value exists.
\item Get an iterator pointing to the first record of a specified hash value.
\item Provide a \hdb map iterator for iterating over hash values.
\item Provide a \hdb multi-map iterator for iterating over all \hdb elements.
\end{compactitem}

\section{Top-Level \hdb Modules}
zzzzzz

1) describe the zmq layer that libhashdb and checker services provides

2) describe the \hdb tool



\end{document}

