
%\documentclass[10pt,twoside,twocolumn]{article}
\documentclass[12pt,twoside]{article}
\usepackage[bf,small]{caption}
\usepackage[letterpaper,hmargin=1in,vmargin=1in]{geometry}
\usepackage{paralist} % comapctitem, compactdesc, compactenum
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage{times}
\usepackage{hyperref}
\usepackage{algorithmic}
\usepackage{graphicx}
\graphicspath{{./graphics/}}
\usepackage{xspace}
\usepackage{verbatim}
\hyphenation{Sub-Bytes Shift-Rows Mix-Col-umns Add-Round-Key}

\setlength{\parskip}{12pt}
\setlength{\parindent}{0pt}

\newcommand{\hdb}{\emph{hashdb}\xspace}
\newcommand{\bulk}{\emph{bulk\_extractor}\xspace}
\newcommand{\mdd}{\emph{md5deep}\xspace}
\newcommand{\hmi}{\textbf{hashdb map iterator}\xspace}
\newcommand{\hmmi}{\textbf{hashdb multimap iterator}\xspace}

\begin{document}

\title{\hdb Design Document}
\author{Bruce Allen}
\maketitle

\begin{abstract}
This document defines the design of the \hdb tool and library
for \hdb v1.0.0, which is different from that of \hdb v0.9.1.
The \hdb Checker and Manager are merged.
the \hdb Library interfaces are changed and support more capability.
\end{abstract}

\section{Changes for v1.0.0}
\paragraph{Database Types}
Two parameters define the database type when creating a new database:
\begin{compactitem}
\item \textbf{Data Size} specifies the block size,
or select 0 to store hashes of any size, useful for managing file hashes.
\item \textbf{Hash Type} specifies the hash type, such as MD5 or SHA1.
We do not mix hash types in a database because hash types have differing sizes.
If mixing hash sizes is really desired, we can truncate or zero-fill
hash values in the database.
\end{compactitem}
\paragraph{Remote Modify}
We can add or remove hash elements remotely over a socket.
\paragraph{Renamed Commands}
Some \hdb tool commands are renamed to specifically indicate their function.

\section{\hdb Services}
\hdb services are provided by the \hdb tool and the \hdb library.
\subsection{\hdb Tool Commands}
\begin{compactitem}
\item Create a \hdb database
\item Import hashes from DFXML
\item Export hashes to DFXML
\item Add hashes in DFXML into database
\item Copy a database to a second database
\item Merge two databases into a third database
\item Erase hashes in DFXML from database
\item Rebuild Bloom filters for database
\item Get hash source information
\item Get database information
\item Run as a Server service
\end{compactitem}

Specifically:
\begin{compactitem}
\item \texttt{create <tuning parameters> <hashdb>} \\
Create a new empty \hdb given the tuning parameters.
\item \texttt{import <repository name> <DFXML file> <hashdb>} \\
Import hashes from the DFXML file into the existing \hdb
using the given repository name.
\item \texttt{export <hashdb> <DFXML file>} \\
Export hashes from the hashdb to the new DFXML file.
\item \texttt{add <hashdb 1> <hashdb 2>} \\
Add database 1 into database 2
using a \hmmi over database 1.
\item \texttt{copy <hashdb 1> <hashdb 2>} \\
Copy database 1 to existing database 2,
possibly excluding some amount of duplicates,
using a \hmmi over database 1.
\item \texttt{merge <hashdb 1> <hashdb 2> <hashdb 3>} \\
Merge databases 1 and 2 into existing database 3
using {\hmmi}s over databases 1 and 2 in sorted order.
\item \texttt{erase <hashdb 1> <hashdb 2>} \\
Erase hashes in database 1 from database 2
using a \hmmi over database 1.
\item \texttt{rebuild bloom <bloom filter parameters> <hashdb>} \\
Rebuild the Bloom filters
using a \hmi over the given database.
\item \texttt{get\_hash\_source <identified\_blocks.txt>} \\
Return source information for the hashes in the specified file.
\item \texttt{get\_hashdb\_info <hashdb>} \\
Retrieve information about the given database.
\item \texttt{server <hashdb>} \\
Start the \hdb tool as a server service using the specified database.
This service uses all \hdb Library interfaces.
\end{compactitem}

\subsubsection{Changes from \hdb v0.9.1}
\begin{compactitem}
\item The parameters for the tuning parameters and bloom filters
remain the same.
\item The \texttt{create} command is new.
The user must create a database before using \texttt{add} or \texttt{merge}.
Alternatively, \texttt{merge} could require parameters for creating
a new database.
\item The \hdb tool uses the \hdb library
for services the \hdb library provides.
\end{compactitem}

\subsection{\hdb Library Interfaces}
\begin{compactitem}
\item Open
\item Insert hashes
\item Erase hashes
\item Find hashes
\item Look up hash sources
\item Get \hdb information
\end{compactitem}

These interfaces permit future expansion to other hash types
by having the hash type in their name.
To start, the \emph{MD5} hash type is supported.

% open
\subsubsection{Open \hdb}
Open a \hdb service that uses the database at the given file path or socket.
If the string contains adjacent // markers, a socket is indicated,
otherwise a file path is indicated.
Here is the constructor:
\begin{small}
\begin{verbatim}
hashdb_md5_h(const std::string &hashdb_service);
\end{verbatim}
\end{small}

% insert hashes
\subsubsection{Insert Hashes}
Insert the hashes and their associated source information
into the opened database and log the change to file \texttt{log}.
\begin{small}
\begin{verbatim}
insert_md5_hashes(const insert_md5_hashes_t &insert_hashes);

struct insert_md5_hash_t {
    uint8_t digest[16];
    std::string repository_name;
    std::string filename;
    uint64_t file_offset;
};

typedef std::vector<insert_md5_hash_t> insert_md5_hashes_t;
\end{verbatim}
\end{small}

% erase hashes
\subsubsection{Erase Hashes}
Removes hashes that exactly match the specified source information
and log the change to file \texttt{log}.
The data structure required for erasing hashes
is the same as that for inserting hashes.

\begin{small}
\begin{verbatim}
erase_md5_hashes(const erase_md5_hashes_t& erase_hashes);

typedef insert_md5_hash_t erase_md5_hash_t;

typedef insert_md5_hashes_t erase_md5_hashes_t;
\end{verbatim}
\end{small}

% find hashes
\subsubsection{Find Hashes}
Finds matching hashes and returns the hashes that match,
along with the \emph{source lookup encoding}
associated with matching hashes.
A hash index is used so that the callee can map responses back
to their original request entries.

\begin{small}
\begin{verbatim}
find_md5_hashes(const find_md5_hashes_t &find_hashes,
            found_md5_hashes_t &found_hashes);

struct find_md5_hash_t {
    uint32_t id;
    uint8_t digest[16];
};

typedef std::vector<find_md5_hash_t> find_md5_hashes_t;

struct found_md5_hash_t {
    uint32_t id;
    uint8_t digest[16];
    uint32_t count;
};

typedef std::vector<found_md5_hash_t> found_md5_hashes_t;
\end{verbatim}
\end{small}

% look up hash sources
\subsubsection{Look Up Hash Sources}
Look up source information for hash values provided.
There may be multiple sources for a hash value.
Source information consists of the repository name, filename, and file offset
of where the hash was sourced from.

\begin{small}
\begin{verbatim}
look_up_md5_hash_sources(const look_up_md5_hash_sources_t& look_up_hash_sources,
                         looked_up_md5_hash_sources_t& looked_up_hash_sources);

struct look_up_md5_hash_source_t {
    uint8_t digest[16];
};

typedef std::vector<look_up_md5_hash_source_t> look_up_md5_hash_sources_t;

struct looked_up_md5_hash_source_t {
    std::string repository_name;
    std::string filename;
    uint64_t file_offset;
};

typedef std::vector<pair<uint8_t[16], std::vector<looked_up_md5_hash_source_t>
                looked_up_md5_hash_sources_t;
\end{verbatim}
\end{small}

% get hashdb info
\subsubsection{Get \hdb Information}
Returns information about the opened database.

\begin{small}
\begin{verbatim}
get_hashdb_info(std::string& information);
\end{verbatim}
\end{small}

\subsection{\hdb Server}
The \hdb server services requests issued to the \hdb library.
\hdb server actions are straightforward.

When a \hdb library service or the \hdb tools need to use a \hdb server,
and the service is at a local path rather than at a socket,
it should perform the following steps:
\begin{algorithmic}
\STATE create the server service as a thread using the machine-local socket
\STATE use the server service using the system-local socket
\STATE destroy the locally running server service thread
\end{algorithmic}

Here is the basic flow for the \hdb server:
\begin{algorithmic}
\STATE Instantiate a \hdb element manager
\WHILE{true}
  \IF{add hashes}
    \STATE create the change logger
    \WHILE{hashes to add}
      \STATE add hash using the \hdb element manager
    \ENDWHILE
  \ELSIF{remove hashes}
    \STATE create the change logger
    \WHILE{hashes to remove}
      \STATE remove hash using the \hdb element manager
    \ENDWHILE
  \ELSIF{find hashes}
    \WHILE{hashes to look up}
      \IF{match}
        \STATE add hash and count to response
      \ENDIF
    \ENDWHILE
  \ELSIF{get info}
    \STATE put info into response
  \ENDIF
\ENDWHILE
\end{algorithmic}

\section{\hdb Modules}
\subsection{\hdb Element Manager}
The \texttt{hashdb\_element\_manager\_t}
provides all services required for working with \hdb elements.
The \hdb library API drives this module directly.
The \hdb tool drives this module directly,
and, for some functions, specifically lookup, add, and delete,
may also drive the \hdb library API.

The \hdb element manager works with \hdb elements, described later.
Changes to the \hdb are noted in the \hdb change logger.

Interfaces are:
\begin{compactitem}
\item Open a \hdb database as new, RW, or RO
\item Insert a \hdb element, noting the change.
\item Remove a \hdb element, noting the change.
\item See if a hash value exists.
\item Provide a \hmmi pointing to the first \hdb element
containing a specified hash value.
\hmmi dereferences to \texttt{hashdb\_element\_t}.
\item Provide a \hmi for iterating over hash values.
\hmi dereferences to \texttt{std::pair<uint8\_t[SIZE], uint32\_t>}
to provide hash and count values.
\item Provide a \hmmi for iterating over all \hdb elements.
\end{compactitem}

% instantiation
\subsubsection{Open a \hdb Database}
Open a \hdb database at the specified directory
with a file mode of new, read-only, or read-write.
Operations may be performed with this database as allowed by its mode.

\begin{small}
\begin{verbatim}
hashdb_db_manager_t(const std::string &hashdb_dir, file_mode_t file_mode_type);
\end{verbatim}
\end{small}

% insert hash
\subsubsection{Insert Hash}
Insert the specified hash, noting the change.

\begin{small}
\begin{verbatim}
insert_hash(const hashdb_element_t &hashdb_element,
            hashdb_change_object_t &hashdb_change_object);
\end{verbatim}
\end{small}

% erase hash
\subsubsection{Erase Hash}
Insert the specified hash, noting the change.

\begin{small}
\begin{verbatim}
erase_hash(const erase_md5_hash_t &erase_hash,
           hashdb_change_object_t &hashdb_change_object);
\end{verbatim}
\end{small}

% find hash count
\subsubsection{Count}
Returns the number of elements containing the given hash value.

\begin{small}
\begin{verbatim}
uint32_t count(md5_t md5);
\end{verbatim}
\end{small}

% equal range
\subsubsection{Equal Range}
Returns pair of \hmmi to lower bound
(first element with key not less than value)
and upper bound (first element with key greater than value or end).

\begin{small}
\begin{verbatim}
pair<const_hashdb_multimap_iterator lower,
    const_hashdb_multimap_iterator upper> equal_range(md5_t md5);
\end{verbatim}
\end{small}

% hmi begin
\subsubsection{\hmi Begin}
Returns begin for \hmi.

\begin{small}
\begin{verbatim}
const_hashdb_map_iterator hashdb_map_begin();
\end{verbatim}
\end{small}

% hmi end
\subsubsection{\hmi End}
Returns end for \hmi.

\begin{small}
\begin{verbatim}
const_hashdb_map_iterator hashdb_map_end();
\end{verbatim}
\end{small}

% hmmi begin
\subsubsection{\hmmi Begin}
Returns begin for \hmmi.

\begin{small}
\begin{verbatim}
const_hashdb_multimap_iterator hashdb_multimap_begin();
\end{verbatim}
\end{small}

% hmmi end
\subsubsection{\hmmi End}
Returns end for \hmmi.

\begin{small}
\begin{verbatim}
const_hashdb_multimap_iterator hashdb_multimap_end();
\end{verbatim}
\end{small}

% \hdb element
\subsection{\hdb Element}
A \hdb element consists of a hash value and where it was sourced from.
Specifically:
\begin{small}
\begin{verbatim}
struct hashdb_element_t {
    uint8_t digest[SIZE];
    std::string repository_name;
    std::string filename;
    uint64_t file_offset;
};
\end{verbatim}
\end{small}

\subsection{\hdb Change Logger}
This structure is used for tracking changes to the \hdb.
The \hdb element manager increments variables
as requests are made to insert or remove \hdb elements.
Changes are written to file \texttt{log}
when the change logger instance is destroyed.
Additional interfaces permit additional logging,
specifically, timestamp and settings.

\begin{small}
\begin{verbatim}
class hashdb_change_logger_t {
      // insert
      uint32_t hashes_inserted;
      uint32_t hashes_not_inserted_invalid_file_offset;
      uint32_t hashes_not_inserted_wrong_hash_block_size;
      uint32_t hashes_not_inserted_wrong_hashdigest_type;
      uint32_t hashes_not_inserted_exceeds_max_duplicates;
      uint32_t hashes_not_inserted_duplicate_source;

      // remove
      uint32_t hashes_removed;
      uint32_t hashes_not_removed_invalid_file_offset;
      uint32_t hashes_not_removed_wrong_hash_block_size;
      uint32_t hashes_not_removed_wrong_hashdigest_type;
      uint32_t hashes_not_removed_no_hash;
      uint32_t hashes_not_removed_different_source;

      // constructor
      hashdb_change_logger_t(const std::string &hashdb_dir,
                             const std::string title);

      // log timestamp
      void add_timestamp(std::string text);

      // log hashdb_settings
      void add_hashdb_settings(const hashdb_settings_t &hashdb_settings);

      // hashdb_db_manager state
//      void add_hashdb_db_manager_state(const hashdb_db_manager_t &manager);
      void add_hashdb_db_manager_state(); // TBD

      // bloom state, this may be temporary
      void add_bloom_state(const bloom_filter_t &bloom_filter, int index);
};
\end{verbatim}
\end{small}

Note that logs are now written at the \hdb library level
for each invocation of the library,
rather than at the tool level, which logged once
for the invocation of the \hdb tool.
This is different from v0.9.1.

% source lookup manager
\subsection{Source Lookup Manager}
This module manages source lookups.
\begin{compactitem}
\item It wraps source lookup capability under one purposed interface.
\item It manages the lookup store, filename store,
and repository name store files required by the three B-Tree multisets,
and uses these storage files: \\
\texttt{
source\_lookup\_store.dat \\
source\_lookup\_store.idx1 \\
source\_lookup\_store.idx2 \\
source\_filename\_store.dat \\
source\_filename\_store.idx1 \\
source\_filename\_store.idx2 \\
source\_repository\_name\_store.dat \\
source\_repository\_name\_store.idx1 \\
source\_repository\_name\_store.idx2
}
\item Provides Interfaces to get source information
from \texttt{source\_lookup\_index},
to get the \texttt{source\_lookup\_index} from source information,
and to insert elements by specifying the repository name, filename,
and \texttt{source\_lookup\_index}.
\end{compactitem}

Source lookup manager interfaces follow.
% constructor
\subsubsection{Constructor}
Open the source lookup manager with file mode of new, RO, or RW.
\begin{small}
\begin{verbatim}
source_lookup_manager_t(const std::string p_hashdb_dir,
                        file_mode_type_t file_mode);
\end{verbatim}
\end{small}

% get source location
\subsubsection{Get Source Location}
Return the repository name and filename from the source lookup index.
\begin{small}
\begin{verbatim}
bool get_source_location(uint64_t source_lookup_index,
                         std::string &repository_name,
                         std::string &filename);
\end{verbatim}
\end{small}

% get source lookup index
\subsubsection{Get Source Lookup Index}
Return the source lookup index from the repository name and filename.
\begin{small}
\begin{verbatim}
bool get_source_lookup_index(const std::string &repository_name,
                             const std::string &filename,
                             uint64_t source_lookup_index);
\end{verbatim}
\end{small}

% insert source lookup element
\subsubsection{Insert Source Lookup Element}
Add a source lookup element, specifically, a repository name and filename,
and get back the new (or already existing) source lookup index.
\begin{small}
\begin{verbatim}
bool insert_source_lookup_element(const std::string &repository_name,
                                  const std::string &filename,
                                  uint64_t &source_lookup_index);
\end{verbatim}
\end{small}

\subsection{Bloom Filter}
\hdb uses two Bloom filters.
The Bloom filter module manages one Bloom filter instance.

% instantiation
\subsubsection{Instantiation}
Create one Bloom filter.
\begin{small}
\begin{verbatim}
bloom_filter_t(const std::string &filename,
               file_mode_type_t file_mode,
               const bloom_settings_t bloom_settings);
\end{verbatim}
\end{small}

% add hash value
\subsubsection{Add Hash Value}
Add one hash value to the Bloom filter.
\begin{small}
\begin{verbatim}
void add_hash_value(const uint8_t[SIZE] &hash);
\end{verbatim}
\end{small}

% is positive
\subsubsection{Is Positive}
Return true if the lookup is positive, indicating the hash value may be present.
\begin{small}
\begin{verbatim}
is_positive(const uint8_t[SIZE] &hash);
\end{verbatim}
\end{small}


\subsection{\hdb Settings}
The \hdb element manager and
many of the storage types in the \hdb database use configurable \hdb settings.
The \hdb Element Manager requires the proper \hdb settings
in order to open most of the file-based resources properly.
The settings manager is in charge of creating or copying a settings object
or saving or loading one from a \texttt{settings} file.

% instantiation
\subsubsection{Instantiation}
Create a \hdb settings object:

\begin{small}
\begin{verbatim}
// new
hashdb_settings_t();

// from file
hashdb_settings_t(std::string hashdb_dir);

// make a copy
hashdb_settings_t(hashdb_settings_t);
\end{verbatim}
\end{small}

% instantiation
\subsubsection{Save Settings}
\begin{small}
\begin{verbatim}
save_settings(std::string hashdb_dir);
\end{verbatim}
\end{small}


\section{Low-Level \hdb Modules}

% hash store
\subsection{Hash Store}
This module manages mapped hash storage.
\begin{compactitem}
\item This provides a map of hashes (as opposed to a multimap).
\item Elements consist of a
\texttt{uint8\_t[SIZE]} block hash key and a
\texttt{uint64\_t}source lookup encoding value.
\item The source lookup encoding consists of $32-40$ bits
of source lookup index and $32-24$ bits of block offset value.
\item Hash storage maps to the \texttt{hash\_store} file.
\item Provides Interfaces to insert, erase, look up, and change elements.
\item Iterator \texttt{hash\_store\_iterator\_t} is available
for walking the hash store.
\end{compactitem}

% hash duplicates store
\subsection{Hash Duplicates Store}
This module manages storage for hash duplicates.
\begin{compactitem}
\item This provides a multimap of hashes.
\item Hash duplicates storage maps to the \texttt{hash\_duplicates\_store} file.
\item Elements consist of a
\texttt{uint8\_t[SIZE]} block hash key and a
\texttt{uint64\_t} source lookup encoding value.
\item Provides interfaces to insert, erase, and look up elements.
\item No iterator is provided with this interface.
\end{compactitem}

% source lookup encoding
\subsection{Source Lookup Encoding}
The source lookup encoding is an overloaded bit-packed optimized
\texttt{uint64\_t}
data structure for looking up the source of a hash.
Algorithms to work with the structure are
implemented as class \texttt{source\_lookup\_encoding\_t}
with static accessors.
Here are some properties of the source lookup encoding:
\begin{compactitem}
\item If the embedded count value $=$ 1,
the source lookup index and hash block offset value
have valid source lookup values.
The \texttt{uint64\_t} value is distributed between the
source lookup index and hash block offset as follows:
  \begin{compactitem}
  \item number of index bits goes into the source lookup index.
  \item 32 $-$ number of index bits goes into the hash block offset value.
  \end{compactitem}
\item If the embedded count value $>$ 1,
the source lookup index and hash block offset value accessors
are not used and return 0.
\item If the hash is a file hash, the block offset value will be 0, as expected.
\item If an attempt is made to compose a source lookup encoding
from a source lookup index value or a hash block offset value
that is too large, an error will be emitted to \texttt{stderr}
and 0 will be returned.
\item A count value is indicated when the most significant 32 bits
of the \texttt{uint64\_t} $=$ \texttt{0xffff}.
\end{compactitem}

%% constructor
%\subsubsection{Constructor}
%Create a storable source lookup encoding:
%\begin{small}
%\begin{verbatim}
%source_lookup_encoding_t(number_of_index_bits_type_t number_of_index_bits_type,
%                         uint64_t source_lookup_index,
%                         uint64_t hash_block_offset_value);
% 
%source_lookup_encoding_t(uint32_t count);
%\end{verbatim}
%\end{small}

% accessors
\subsubsection{Accessors}
\begin{small}
\begin{verbatim}
static uint64_t get_source_lookup_encoding_t(
                 uint8_t number_of_index_bits,
                 uint64_t source_lookup_index,
                 uint64_t hash_block_offset_value);

static uint64_t get_source_lookup_encoding_t(uint32_t count);

static uint32_t get_count(uint64_t source_lookup_encoding);

static uint64_t get_source_lookup_index(
                 uint8_t number_of_index_bits,
                 uint64_t source_lookup_encoding);

static uint64_t get_hash_block_offset_value(
                 uint8_t number_of_index_bits,
                 uint64_t source_lookup_encoding);
\end{verbatim}
\end{small}

\end{document}

