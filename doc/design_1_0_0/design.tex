
%\documentclass[10pt,twoside,twocolumn]{article}
\documentclass[12pt,twoside]{article}
\usepackage[bf,small]{caption}
\usepackage[letterpaper,hmargin=1in,vmargin=1in]{geometry}
\usepackage{paralist} % comapctitem, compactdesc, compactenum
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage{times}
\usepackage{hyperref}
\usepackage{algorithmic}
\usepackage{graphicx}
\graphicspath{{./graphics/}}
\usepackage{xspace}
\usepackage{verbatim}
\hyphenation{Sub-Bytes Shift-Rows Mix-Col-umns Add-Round-Key}

\setlength{\parskip}{12pt}
\setlength{\parindent}{0pt}

\newcommand{\hdb}{\emph{hashdb}\xspace}
\newcommand{\bulk}{\emph{bulk\_extractor}\xspace}
\newcommand{\mdd}{\emph{md5deep}\xspace}
\newcommand{\mi}{\textbf{map iterator}\xspace}
\newcommand{\mmi}{\textbf{multimap iterator}\xspace}

\begin{document}

\title{\hdb Design Document}
\author{Bruce Allen}
\maketitle

\begin{abstract}
This document defines the design of the \hdb tool and library
for \hdb v1.0.0, which is different from that of \hdb v0.9.1.
The \hdb Checker and Manager tools are merged into one \hdb tool.
the \hdb Library interfaces are changed to support more capability
more cleanly.
\end{abstract}

\section{Changes for v1.0.0}
Changes from \hdb v0.9.1:
\begin{compactitem}
\item Multiple hashdigest types are supported, including MD5, SHA1, SHA256.
Hashdigest types cannot be mixed in a single \hdb database.
\item \hdb database creation is a separate operation and is no longer embedded
with other actions such as \texttt{import} or \texttt{add}.
\item The \hdb library supports interfaces for creating and populating a new
\hdb database.
\item Command syntax has been modified, please see usage.
\item The \texttt{intersect} command has been added
to support similarity detection.
\item The \texttt{get\_hashdb\_sources} command has been added
to display source information, particulary useful after a \hdb
has been reduced to specific content using the \texttt{intersect} command.
\end{compactitem}

\section{\hdb Services}
\hdb services are provided by the \hdb tool and the \hdb library.
\subsection{\hdb Tool Commands}
\begin{compactitem}
\item Create a \hdb database
\item Import hashes from DFXML
\item Export hashes to DFXML
\item Add hashes in DFXML into database
\item Copy a database to a second database
\item Merge two databases into a third database
\item Remove hashes in DFXML from database
\item Rebuild Bloom filters for database
\item Get hash source information
\item Get database information
\item Run as a Server service
\end{compactitem}

Specifically:
\begin{compactitem}
\item \texttt{create <hashdb settings> <bloom filter settings> <hashdb>} \\
Create a new empty \hdb given the specified settings.
\item \texttt{import [-r <repository name>] <DFXML file> <hashdb>} \\
Import hashes from the DFXML file into the existing \hdb
using the given repository name.
\item \texttt{export <hashdb> <DFXML file>} \\
Export hashes from the hashdb to the new DFXML file.
\item \texttt{copy <hashdb 1> <hashdb 2>} \\
Copy hashes in database 1 into database 2.
\item \texttt{add <hashdb 1> <hashdb 2> <hashdb 3>} \\
Perform a union of databases 1 and 2 into 3, in sorted order.
\item \texttt{intersect <hashdb 1> <hashdb 2> <hashdb 3>} \\
Copy the intersection of databases 1 and 2 into database 3.
Intersection is when hash values match, even if their associated source
repository name and filename do not match.
\item \texttt{subtract <hashdb 1> <hashdb 2> <hashdb3>} \\
Copy hashes that are in hashdb1 and not in hashdb2 into hashdb3.
Hashes match when their hash values match, even if their associated source
repository name and filename do not match.
\item \texttt{deduplicate <hashdb1> <hashdb2>} \\
Copy hashes in hashdb1 to hashdb2,
except for hashes that appear more than once.
\item \texttt{rebuild\_bloom <bloom filter settings> <hashdb>} \\
Rebuild the Bloom filter with the new settings for the hashdb.
\item \texttt{server <hashdb> <socket>} \\
Start the \hdb tool as a server lookup service using the database
at the specified socket.
\item \texttt{scan <hashdb> <DFXML file>} \\
Print out hashes in the \hdb that match hashes in the DFXML file.
\item \texttt{expand\_identified\_blocks <hashdb> <identified\_blocks.txt>} \\
For each hash in \texttt{identified\_blocks.txt},
print out the hash with full source lookup information,
specifically, the source repository name, filename, and file offset
of every instance where the hash value was sourced.
\item \texttt{get\_sources <hashdb>} \\
Print out all repository name and filename sources in the specified database.
\item \texttt{get\_statistics <hashdb>} \\
Print out statistics about the given database.
\end{compactitem}

\subsection{\hdb Library Interfaces}
Two capabilities are provided:
\begin{compactitem}
\item Open read-only to find hashes in an existing \hdb
\item Open write-only to insert hashes into a new \hdb
\end{compactitem}

These interfaces are greatly simplified from the original concept,
which was to provide all \hdb capabilities remotely.

Instead, the library provides interfaces to create a new \hdb
or to search an existing \hdb locally or remotely,
and relies on the portability of \hdb databases
so that users move databases onto one system
where the \hdb tool is then used
to perform all desired operational functions.

These interfaces are provided as files:
\begin{compactitem}
\item \texttt{hashdb.hpp}
\item \texttt{libhashdb.la}
\item \texttt{libhashdb.a}
\end{compactitem}

Interfaces follow:

%// open for importing
%int create_hashdb(const std::string& hashdigest_type,
%                  uint32_t block_size,
%                  uint32_t max_duplicates)
%// open for scanning
%int open_hashdb_scanner(const std::string& path_or_socket);
\begin{small}
\begin{verbatim}
// data structures for import
template<typename T>
struct import_element_t {
  T hash;
  std::string repository_name;
  std::string filename;
  uint64_t file_offset;
  import_element_t(T p_hash,
                 std::string p_repository_name,
                 std::string p_filename,
                 uint64_t p_file_offset) :
                        hash(p_hash),
                        repository_name(p_repository_name),
                        filename(p_filename),
                        file_offset(p_file_offset) {
  }
};
typedef std::vector<import_element_t<md5_t> > import_input_md5_t;
typedef std::vector<import_element_t<sha1_t> > import_input_sha1_t;
typedef std::vector<import_element_t<sha256_t> > import_input_sha256_t;

// data structures for scan
typedef std::vector<std::pair<uint64_t, md5_t> >    scan_input_md5_t;
typedef std::vector<std::pair<uint64_t, sha1_t> >   scan_input_sha1_t;
typedef std::vector<std::pair<uint64_t, sha256_t> > scan_input_sha256_t;
typedef std::vector<std::pair<uint64_t, uint32_t> > scan_output_t;

// constructor for importing
hashdb_t(const std::string& hashdb_dir,
         const std::string& hashdigest_type,
         uint32_t block_size,
         uint32_t max_duplicates);

// Import
int import(const import_input_md5_t& import_input_md5);
int import(const import_input_sha1_t& import_input_sha1);
int import(const import_input_sha256_t& import_input_sha256);

// constructor for scanning
hashdb_t(const std::string& path_or_socket);

// Scan
int scan(const scan_input_md5_t& scan_input_md5,
         scan_output_t& scan_output);
int scan(const scan_input_sha1_t& scan_input_sha1,
         scan_output_t& scan_output);
int scan(const scan_input_sha256_t& scan_input_sha256,
         scan_output_t& scan_output);
\end{verbatim}
\end{small}

For importing, if the \texttt{path\_or\_socket} string
contains adjacent // markers, a socket is opened for scanning,
otherwise a database at the given path is opened for scanning.

All functions return 0 unless there was an error.


%\subsection{\hdb Server}
%The \hdb server service performs lookup queries on the \hdb library.
%The \hdb server workflow is simple:
%
%\begin{algorithmic}
%\STATE Instantiate a \hdb element manager
%\WHILE{true}
%  \STATE wait for vector of hashes with their ID
%  \STATE scan the \hdb for matching hases
%  \STATE for matches, return matching hashes, their ID, and the match count
%\ENDWHILE
%\end{algorithmic}

\subsection{\bulk \hid Scanner}
The \bulk \hid scanner supports \texttt{import} and \texttt{scan} modes:
\begin{compactitem}
\item \texttt{scan} mode scans against a \hdb database
and places hash features that match into feature file \texttt{identified\_blocks.txt}.
\item \texttt{import} mode creates a \hdb database
in the \bulk output directory under database directory \texttt{hashdb}.
\end{compactitem}

\hid scanner options are entered using \bulk \texttt{-S} parameter options:
\begin{compactitem}
\item \texttt{hashdb\_mode=[none|import|scan]}
selects the \hid scanner mode of operation.
Default is \texttt{none}, in which case the \hid scanner does nothing.
\item \texttt{hashdb\_hashdigest\_type=[MD5|SHA1|SHA256]}
For \texttt{import}, selects the hashdigest type to use for the hash database.
For \texttt{scan}, selects the hashdigest type to use
when generating hash blocks to be scanned.
Default is \texttt{MD5}.
\item \texttt{hashdb\_block\_size=<block size>}
selects the block size to use for generating hashes.
Default is 4096.
\item \texttt{hashdb\_max\_duplicates=<max duplicates>}
selects the maximum number of duplicates to import for a given hash value.
Default is 20.
Valid only for \texttt{import} mode.
\item \texttt{hashdb\_path\_or\_socket=<path or socket>}
selects the file path to a hash database
or, if the text contains adjacent // markers,
selects the socket to a \hdb server.
Valid only for \texttt{scan} mode.
\item \texttt{hashdb\_sector\_size=<sector size>}
selects the sector size.
When scanning, generate hash values to search for along sector boundaries.
Default is 512.
Valid only for \texttt{scan} mode.
\end{compactitem}

\section{File Modules - Mid-Level Database File Drivers}
File modules manage access to database files.
They are typically initialized with \texttt{hashdb\_dir} and file access mode
\texttt{RW\_NEW}, \texttt{RW\_MODIFY}, or \texttt{READ\_ONLY}.
They require hash key type \texttt{<T>}.

\begin{compactitem}
\item Map Manager
\item Map Iterator
\item Multmiap Manager
\item Multimap Iterator
\item Source Lookup Index Manager
\item Bloom Filter Manager
\item Settings Manager
\item Logger
\end{compactitem}

% map manager
\subsection{Map Manager}
This module manages mapped hash storage.
It has been renamed from \textit{Hash Store}.
\begin{compactitem}
\item The key \texttt{T} is the \texttt{uint8\_t[SIZE]} hash digest such as MD5,
and the payload value is the \texttt{uint64\_t} source lookup encoding.
\item The source lookup encoding consists of $32-40$ bits
of source lookup index and $32-24$ bits of block offset value,
but this detail does not matter to the Map Manager.
\item The hash map maps to the \texttt{hash\_map\_store} file.
\item Provides Interfaces to insert, erase, look up, and change elements.
\item An iterator is available for walking the hash map.
\end{compactitem}

Here are the interfaces:
\begin{small}
\begin{verbatim}
map_manager_t<class T>(const std::string& hashdb_dir,
                       file_mode_type_t file_mode,
                       map_type_t map_type);
pair<map_iterator_t<T>, bool> emplace(const T& key,
                                      uint64_t source_lookup_encoding);
bool erase(const T& key);
pair<map_iterator_t<T>, bool> change(const T& key,
                                      uint64_t source_lookup_encoding);
map_iterator_t<T> find(const T& key);
uint32_t find_count(const T& key);   // convenience, specific use of find
map_iterator_t<T> begin() const;
map_iterator_t<T> end() const;
size_t size();
\end{verbatim}
\end{small}

% map iterator
\subsection{Map Iterator}
\texttt{map\_iterator\_t} dereferences to
key, source lookup index pair\texttt{<T, uint64\_t>}.

% multimap manager
\subsection{Multimap Manager}
This module manages multimap hash storage.
It has been renamed from \textit{Hash duplicates Store}.
\begin{compactitem}
\item The key \texttt{T} is the \texttt{uint8\_t[SIZE]} hash digest such as MD5,
and the payload value is the \texttt{uint64\_t} source lookup encoding.
\item The source lookup encoding consists of $32-40$ bits
of source lookup index and $32-24$ bits of block offset value,
but this detail does not matter at this low storage level.
\item The hash multimap maps to the \texttt{hash\_multimap\_store} file.
\item Provides Interfaces to insert, erase, and look up elements.
\item An iterator is available for walking
between elements \texttt{[a,b)} of a key in the hash multimap.
\item Begin and end accessors are not provided.
\end{compactitem}

Here are the interfaces:
\begin{small}
\begin{verbatim}
multimap_manager_t<class T>(string& hashdb_dir,
                            file_mode_type_t file_mode,
                            multimap_type_t multimap_type);
bool emplace(const T& key,
             uint32_t max_duplicates,
             uint64_t source_lookup_encoding);
bool erase(const T& key, uint64_t source_lookup_encoding);
size_t erase_range(const& key T);
pair<multimap_iterator_t<T>, multimap_iterator_t<T>> equal_range(key T);
bool has(const T& key, uint64_t source_lookup_encoding);
bool has_range(const T& key);
size_t size() const;
\end{verbatim}
\end{small}

% multimap iterator
\subsection{Multimap Iterator}
\texttt{multimap\_iterator\_t} dereferences to
key, source lookup index pair\texttt{<T, uint64\_t>}.

% source lookup index manager
\subsection{Source Lookup Index Manager}
This module manages the association between an index
and its associated repository\_name, filename pair.
\begin{compactitem}
\item It wraps source lookup capability under one purposed interface.
\item It manages the lookup store, filename store,
and repository name store files required by the three B-Tree multisets
and uses
\texttt{source\_lookup\_store},
\texttt{source\_filename\_store}, and
\texttt{source\_repository\_name\_store}
filenames, each one with
\texttt{.dat}, \texttt{.idx1}, and \texttt{.idx2} extensions.
\item Provides Interfaces to insert indexes
and to find indexes or repository name, filename pairs.
\end{compactitem}

Here are the interfaces:

\begin{small}
\begin{verbatim}
source_lookup_index_manager_t(hashdb_dir, file_mode);

pair<bool, uint64_t> insert(const std::string& repository_name,
                            const std::string& filename);

pair<bool, uint64_t> find(const std::string& repository_name,
                          const std::string& filename);

pair<string rep_name, string filename> find(uint64_t source_lookup_index);
\end{verbatim}
\end{small}

\subsection{Bloom Filter Manager}
\begin{compactitem}
\item Two Bloom filters are managed, Bloom1 and Bloom2.
\item Initialization parameters set the enabled state and runtime state of both.
\item The \hdb manager uses this to set or check for hashes.
\item Bloom filters help performance by indicating when a hash is not present.
\end{compactitem}

Here are the interfaces:

\begin{small}
\begin{verbatim}
bloom_filter_t<T>(const std::string& filename,
               file_mode_type_t file_mode,
               const lots of settings);

void add_hash_value(const T& key);

is_positive(const T& key);
\end{verbatim}
\end{small}

\subsection{Settings Manager}
Many of the storage types in the \hdb database use configurable \hdb settings.
Refer to \texttt{hashdb\_settings\_t}.

Here are the interfaces:

\begin{small}
\begin{verbatim}
static hashdb_settings_t read_settings(const std::string& hashdb_dir);

static void write_settings(const std::string& hashdb_dir,
                           const hashdb_settings_t& settings);
\end{verbatim}
\end{small}

\subsection{Logger}
The logger manages logging to the \hdb \texttt{log.xml} file.
The log is created when the logger object opens,
and is closed by close or when the logger is destroyed,
for example by losing scope.
 
Here are the interfaces:

\begin{small}
\begin{verbatim}
logger_t(hashdb_dir);
void add_timestamp(name);
void add_hashdb_settings(const hashdb_settings_t& settings);
void add_hashdb_changes(const hashdb_changes_t& changes);
template<typename T> void add(const std::string& tag, const T& value);
\end{verbatim}
\end{small}

\section{Map-Multimap Abstraction Layer}
\begin{compactitem}
\item The Map-Multimap abstraction layer
provides a unified \hdb treatment of the map and multimap
while still using lower-level \texttt{T key}
and \texttt{uint64\_t source\_lookup\_encoding} types
rather than the higher-level \texttt{hashdb\_element\_t} class.
\item The Map-Multimap abstraction layer fits above the file modules
and below the \hdb modules.
\item It consists of \texttt{map\_multimap\_manager\_t<T>}
and \texttt{map\_multimap\_iterator\_t<T>}.
\end{compactitem}

\subsection{Map-Multimap Manager}
The \texttt{map\_multimap\_manager\_t}
provides services required for accessing the hash database
as a whole.  It hides the map manager, multimap manager, and bloom filter.
Changes to the \hdb are noted in \texttt{hashdb\_changes\_t}.

Actions:
\begin{compactitem}
\item Open a hash database as
\texttt{RW\_NEW}, \texttt{RW\_MODIFY}, or \texttt{READ\_ONLY}.
\item Emplace a \texttt{T, source\_lookup\_encoding} entry noting the change.
\item Remove a \texttt{T, source\_lookup\_encoding} entry noting the change.
\item Remove a \texttt{T} entry noting the change.
\item See if T key exists, checking Bloom first.
\item Provide a \texttt{map\_multimap\_iterator} via begin() and end()
for iterating over all hash values.
Iterator dereferences to \texttt{pair<T, uint64\_t}.
\item Provide zero-overhead size functions for map and multimap,
more for completeness than for usefulness.
\end{compactitem}

Interfaces:

\begin{small}
%zzzz removed bool has_key(const T& key);
\begin{verbatim}
map_multimap_manager_t<T>(const std::string& hashdb_dir,
                          file_mode_t file_mode_type);

void emplace(const T& key, uint64_t source_lookup_encoding,
             hashdb_changes_t &hashdb_changes);

void remove(const T& key, uint64_t source_lookup_encoding,
            hashdb_changes_t& hashdb_changes);

void remove_key(const T& key, hashdb_changes_t& hashdb_changes);

pair<map_multimap_iterator_t<T>>, map_multimap_iterator_t<T>>
     find(const T& key);

uint32_t find_range(const T& key);

pair<T, uint64_t> begin() const;

pair<T, uint64_t> end() const;

size_t map_size();

size_t multimap_size();
\end{verbatim}
\end{small}

% map_multimap iterator
\subsection{Map-Multimap Iterator}
\texttt{map\_multimap\_iterator\_t<T>} dereferences to \\
\texttt{pair(T key, uint64\_t source\_lookup\_encoding\_t)}.

\section{\hdb Modules}
\subsection{\hdb Manager}
The \texttt{hashdb\_manager\_t}
provides services required for accessing the hash database
as a whole.  It hides the map manager, multimap manager, and bloom filter.
Changes to the \hdb are noted in the \hdb change logger.

Actions:
\begin{compactitem}
\item Open a hash database as
\texttt{RW\_NEW}, \texttt{RW\_MODIFY}, or \texttt{READ\_ONLY}.
\item Insert a \texttt{hashdb\_element\_t} entry noting the change.
\item Remove a \texttt{hashdb\_element\_t} entry noting the change.
\item Remove all elements of a key
specified by \texttt{hashdigest\_t}, noting the change.
\item See if a hash identified by key in
type \texttt{hashdigest\_t} exists, checking Bloom first.
\item Provide a \hdb iterator via begin() and end()
for iterating over all hash values.
\end{compactitem}

Interfaces:

% hashdb manager
\begin{small}
\begin{verbatim}
hashdb_manager_t(const std::string& hashdb_dir,
                 file_mode_t file_mode);

void insert(const hashdb_element_t&, hashdb_changes_t&);

void remove(const hashdb_element_t&, hashdb_changes_t&);

void remove_key(const hashdigest_t&, hashdb_changes_t&);

pair<hashdb_iterator_t, hashdb_iterator_t> find(hashdigest_t);
pair<hashdb_iterator_t, hashdb_iterator_t> find(T key);
uint32_t find_count(hashdigest_t);
uint32_t find_count(T key);

size_t map_size();

size_t multimap_size();

hashdb_iterator_t begin() const;

hashdb_iterator_t end() const;
\end{verbatim}
\end{small}

% hashdb iterator
\subsection{\hdb Iterator}
\hdb iterator dereferences to \texttt{hashdb\_element\_t}.

% hashdigest type
\subsection{Hashdigest Type}
\texttt{hashdigest\_t} contains a hash value and its type
as strings, unbound from its native hash type.
\begin{small}
\begin{verbatim}
struct hashdigest_t {
  std::string hashdigest;
  std::string hashdigest_type;    // MD5, SHA1, etc.

  hashdigest_t(string hashdigest, string hashdigest_type);
  hashdigest_t(md5_t);
  hashdigest_t(sha1_t);
  hashdigest_t(sha256_t);
};
\end{verbatim}
\end{small}

% hashdb element
\subsection{Hashdb Element}
A \texttt{hashdb\_element\_t} fully qualifies a hash source.
\begin{compactitem}
\item It has all the fields required to fully define a hash source.
\item The \texttt{hashdigest} is a string, so we don't to use \texttt{<T>}.
\end{compactitem}

Specifically:
\begin{small}
\begin{verbatim}
struct hashdb_element_t {
    std::string hashdigest;
    std::string hashdigest_type;    // MD5, SHA1, etc.
    uint32_t block_size;            // e.g. 4096
    std::string repository_name;
    std::string filename;
    uint64_t file_offset;
};
\end{verbatim}
\end{small}

\subsection{\hdb Changes}
This structure is used for tracking changes to the \hdb.
The \hdb manager increments these variables
as requests are made to insert or remove \hdb elements.
Use the \texttt{logger} to log \hdb changes.

Note that logs are now written at the \hdb library level
for each invocation of the library,
rather than at the tool level, which logged once
for the invocation of the \hdb tool.
This is different from v0.9.1.

\begin{small}
\begin{verbatim}
class hashdb_changes_t {
      // insert
      uint32_t hashes_inserted;
      uint32_t hashes_not_inserted_mismatched_hash_block_size;
      uint32_t hashes_not_inserted_file_offset_not_aligned;
      uint32_t hashes_not_inserted_mismatched_hashdigest_type;
      uint32_t hashes_not_inserted_exceeds_max_duplicates;
      uint32_t hashes_not_inserted_duplicate_element;

      // remove
      uint32_t hashes_removed;
      uint32_t hashes_not_removed_mismatched_hash_block_size;
      uint32_t hashes_not_removed_file_offset_not_aligned;
      uint32_t hashes_not_removed_mismatched_hashdigest_type;
      uint32_t hashes_not_removed_no_hash;
      uint32_t hashes_not_removed_no_element;
};
\end{verbatim}
\end{small}

% source lookup encoding
\subsection{Source Lookup Encoding}
The source lookup encoding provides algorithms for working with a
\texttt{uint64\_t}
as a source lookup encoding containing a source lookup index,
a hash block offset, and a count value.
These algorithms are
implemented in namespace \texttt{source\_lookup\_encoding}.
This encoding is an optimization for saving space in memory.
Here are some properties of this encoding:
\begin{compactitem}
\item If the embedded count value $=$ 1,
the source lookup index and hash block offset
have valid source lookup values.
The \texttt{uint64\_t} value is distributed between the
source lookup index and hash block offset as follows:
  \begin{compactitem}
  \item number of index bits goes into the source lookup index.
  \item 32 $-$ number of index bits goes into the hash block offset.
  \end{compactitem}
\item If the embedded count value $>$ 1,
the source lookup index and hash block offset accessors
are not used and return 0.
\item If the hash is a file hash, the block offset will be 0, as expected.
\item If an attempt is made to compose a source lookup encoding
from a source lookup index or a hash block offset
that is too large, an error will be emitted to \texttt{stderr}
and 0 will be returned.
\item A count value is indicated when the most significant 32 bits
of the \texttt{uint64\_t} $=$ \texttt{0xffff}.
\end{compactitem}

Here are the interfaces:
\begin{small}
\begin{verbatim}
static uint64_t get_source_lookup_encoding(
                 uint8_t source_lookup_index_bits,
                 uint64_t source_lookup_index,
                 uint64_t hash_block_offset);

static uint64_t get_source_lookup_encoding(uint32_t count);

static uint32_t get_count(uint64_t source_lookup_encoding);

static uint64_t get_source_lookup_index(
                 uint8_t source_lookup_index_bits,
                 uint64_t source_lookup_encoding);

static uint64_t get_hash_block_offset(
                 uint8_t source_lookup_index_bits,
                 uint64_t source_lookup_encoding);
\end{verbatim}
\end{small}



\end{document}

